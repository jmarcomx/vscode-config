exports.id=449,exports.ids=[449],exports.modules={1848:(t,e,r)=>{r.r(e),r.d(e,{GitLabApi:()=>GitLabApi});var a=r(9496),n=r(1177),s=r(7338),i=r(3113),o=r(5255),l=r(4575),u=r(8452),c=r(4092),d=r(1277),h=r(6446),g=r(7925),p=r(4241),m=r(6398),f=r(4627),w=r(6630),b=Object.defineProperty,q=Object.getOwnPropertyDescriptor,y=(t,e,r,a)=>{for(var n,s=a>1?void 0:a?q(e,r):e,i=t.length-1;i>=0;i--)(n=t[i])&&(s=(a?n(e,r,s):n(s))||s);return a&&s&&b(e,r,s),s};class GitLabApi{constructor(t){this._projectIds=new Map,this._proxyAgents=new Map,this._disposable=a.Disposable.from(i.DN.onDidChange((t=>{(i.DN.changed(t,"proxy")||i.DN.changed(t,"remotes"))&&(this._projectIds.clear(),this._proxyAgents.clear())})),i.DN.onDidChangeAny((t=>{(t.affectsConfiguration("http.proxy")||t.affectsConfiguration("http.proxyStrictSSL"))&&(this._projectIds.clear(),this._proxyAgents.clear())})))}dispose(){this._disposable?.dispose()}getProxyAgent(t){if(s.$L)return;let e=this._proxyAgents.get(t.id);if(void 0===e){const r=t.getIgnoreSSLErrors();e=(0,n.Nx)(!0!==r&&"force"!==r&&void 0),this._proxyAgents.set(t.id,e??null)}return e??void 0}async getAccountForCommit(t,e,r,n,s,i){const o=(0,h.UH)(),u=await this.getProjectId(t,e,r,n,i?.baseUrl);if(u)try{const r=await this.request(t,e,i?.baseUrl,`v4/projects/${u}/repository/commits/${s}?stats=false`,{method:"GET"},o);let n;const l=await this.findUser(t,e,r.author_name,i);for(const t of l)if(t.name===r.author_name||t.publicEmail&&t.publicEmail===r.author_email){if(n=t,"active"===t.state)break}else((0,f.qq)(t.name,r.author_name)||t.publicEmail&&(0,f.qq)(t.publicEmail,r.author_email))&&(n=t);if(null==n)return;return n.avatarUrl&&!/^([a-zA-Z][\w+.-]+):/.test(n.avatarUrl)&&(n.avatarUrl=a.Uri.joinPath(a.Uri.parse(n.webUrl),"..",n.avatarUrl).toString()),{provider:t,name:n.name||void 0,email:r.author_email||void 0,avatarUrl:n.avatarUrl||void 0}}catch(e){if(e instanceof l.Ww)return;throw this.handleException(e,t,o)}}async getAccountForEmail(t,e,r,a,n,s){const i=(0,h.UH)();try{const[r]=await this.findUser(t,e,n,s);if(null==r)return;return{provider:t,name:r.name||void 0,email:r.publicEmail||void 0,avatarUrl:r.avatarUrl||void 0}}catch(e){if(e instanceof l.Ww)return;throw this.handleException(e,t,i)}}async getDefaultBranch(t,e,r,a,n){const s=(0,h.UH)();try{const i="query getDefaultBranch(\n\t$fullPath: ID!\n) {\n\tproject(fullPath: $fullPath) {\n\t\trepository {\n\t\t\trootRef\n\t\t}\n}",o=(await this.graphql(t,e,n?.baseUrl,i,{fullPath:`${r}/${a}`},s))?.data?.project?.repository?.rootRef??void 0;if(null==o)return;return{provider:t,name:o}}catch(e){if(e instanceof l.Ww)return;throw this.handleException(e,t,s)}}async getIssueOrPullRequest(t,e,r,a,n,s){const i=(0,h.UH)();try{const o="query getIssueOrMergeRequest(\n\t$fullPath: ID!\n\t$iid: String!\n) {\n\tproject(fullPath: $fullPath) {\n\t\tmergeRequest(iid: $iid) {\n\t\t\tauthor {\n\t\t\t\tname\n\t\t\t\tavatarUrl\n\t\t\t\twebUrl\n\t\t\t}\n\t\t\tiid\n\t\t\ttitle\n\t\t\tdescription\n\t\t\tstate\n\t\t\tcreatedAt\n\t\t\tupdatedAt\n\t\t\tmergedAt\n\t\t\twebUrl\n\t\t}\n\t\tissue(iid: $iid) {\n\t\t\tauthor {\n\t\t\t\tname\n\t\t\t\tavatarUrl\n\t\t\t\twebUrl\n\t\t\t}\n\t\t\tiid\n\t\t\ttitle\n\t\t\tdescription\n\t\t\tstate\n\t\t\tcreatedAt\n\t\t\tupdatedAt\n\t\t\tclosedAt\n\t\t\twebUrl\n\t\t}\n\t}\n}",l=await this.graphql(t,e,s?.baseUrl,o,{fullPath:`${r}/${a}`,iid:String(n)},i);if(null!=l?.data?.project?.issue){const e=l.data.project.issue;return{provider:t,type:u.mX.Issue,id:e.iid,date:new Date(e.createdAt),title:e.title,closed:"closed"===e.state,closedDate:null==e.closedAt?void 0:new Date(e.closedAt),url:e.webUrl}}if(null!=l?.data?.project?.mergeRequest){const e=l.data.project.mergeRequest;return{provider:t,type:u.mX.PullRequest,id:e.iid,date:new Date(e.createdAt),title:e.title,closed:"closed"===e.state,closedDate:"closed"===e.state?new Date(e.updatedAt):void 0,url:e.webUrl}}return}catch(e){if(e instanceof l.Ww)return;throw this.handleException(e,t,i)}}async getPullRequestForBranch(t,e,r,a,n,s){const i=(0,h.UH)();try{const o="\n\t\t\tnodes {\n\t\t\t\tiid\n\t\t\t\tauthor {\n\t\t\t\t\tname\n\t\t\t\t\tavatarUrl\n\t\t\t\t\twebUrl\n\t\t\t\t}\n\t\t\t\ttitle\n\t\t\t\tdescription\n\t\t\t\tstate\n\t\t\t\tcreatedAt\n\t\t\t\tupdatedAt\n\t\t\t\tmergedAt\n\t\t\t\twebUrl\n\t\t\t}",l=`query getMergeRequestForBranch(\n\t$fullPath: ID!\n\t$branches: [String!]\n) {\n\tproject(fullPath: $fullPath) {\n\t\t${null==s?.include?`mergeRequests(sourceBranches: $branches sort: UPDATED_DESC first: 1) {\n\t\t\t${o}\n\t\t}`:""}\n\t\t${s?.include?.includes(w.GitLabMergeRequestState.OPEN)?`opened: mergeRequests(sourceBranches: $branches state: opened sort: UPDATED_DESC first: 1) {\n\t\t\t${o}\n\t\t}`:""}\n\t\t${s?.include?.includes(w.GitLabMergeRequestState.MERGED)?`merged: mergeRequests(sourceBranches: $branches state: merged sort: UPDATED_DESC first: 1) {\n\t\t\t${o}\n\t\t}`:""}\n\t\t${s?.include?.includes(w.GitLabMergeRequestState.CLOSED)?`closed: mergeRequests(sourceBranches: $branches state: closed sort: UPDATED_DESC first: 1) {\n\t\t\t${o}\n\t\t}`:""}\n\t}\n}`,u=await this.graphql(t,e,s?.baseUrl,l,{fullPath:`${r}/${a}`,branches:[n],state:s?.include},i);let d;if(null==s?.include)d=u?.data?.project?.mergeRequests?.nodes?.[0];else for(const t of s.include){let e;t===w.GitLabMergeRequestState.OPEN?e=u?.data?.project?.opened?.nodes?.[0]:t===w.GitLabMergeRequestState.MERGED?e=u?.data?.project?.merged?.nodes?.[0]:t===w.GitLabMergeRequestState.CLOSED&&(e=u?.data?.project?.closed?.nodes?.[0]),null!=e&&(null==d||new Date(e.updatedAt)>new Date(d.updatedAt))&&(d=e)}if(null==d)return;return new c.i7(t,{name:d.author?.name??"Unknown",avatarUrl:d.author?.avatarUrl??"",url:d.author?.webUrl??""},String(d.iid),d.title,d.webUrl,w.GitLabMergeRequest.fromState(d.state),new Date(d.updatedAt),d.state!==w.GitLabMergeRequestState.CLOSED?void 0:new Date(d.updatedAt),null==d.mergedAt?void 0:new Date(d.mergedAt))}catch(e){if(e instanceof l.Ww)return;throw this.handleException(e,t,i)}}async getPullRequestForCommit(t,e,r,a,n,s){const i=(0,h.UH)(),o=await this.getProjectId(t,e,r,a,s?.baseUrl);if(o)try{const r=await this.request(t,e,s?.baseUrl,`v4/projects/${o}/repository/commits/${n}/merge_requests`,{method:"GET"},i);if(null==r||0===r.length)return;return r.length>1&&r.sort(((t,e)=>(t.state===w.GitLabMergeRequestState.OPEN?-1:1)-(e.state===w.GitLabMergeRequestState.OPEN?-1:1)||new Date(e.updated_at).getTime()-new Date(t.updated_at).getTime())),w.GitLabMergeRequestREST.from(r[0],t)}catch(e){if(e instanceof l.Ww)return;throw this.handleException(e,t,i)}}async findUser(t,e,r,a){const n=(0,h.UH)();try{const s="query findUser(\n$search: String!\n) {\n\tusers(search: $search) {\n\t\tnodes {\n\t\t\tid\n\t\t\tname\n\t\t\tusername,\n\t\t\tpublicEmail,\n\t\t\tstate\n\t\t\tavatarUrl\n\t\t\twebUrl\n\t\t}\n\t}\n}",i=(await this.graphql(t,e,a?.baseUrl,s,{search:r},n))?.data?.users?.nodes;if(null==i||0===i.length)return[];const o=[];for(const t of i){const e=/gid:\/\/gitlab\/User\/([0-9]+)\b/.exec(t.id);null!=e&&o.push({id:parseInt(e[1],10),name:t.name,username:t.username,publicEmail:t.publicEmail||void 0,state:t.state,avatarUrl:t.avatarUrl,webUrl:t.webUrl})}return o}catch(e){return e instanceof l.Ww||this.handleException(e,t,n),[]}}getProjectId(t,e,r,a,n){const s=`${e}|${r}/${a}`;let i=this._projectIds.get(s);return null==i&&(i=this.getProjectIdCore(t,e,r,a,n),this._projectIds.set(s,i)),i}async getProjectIdCore(t,e,r,a,n){const s=(0,h.UH)();try{const i="query getProjectId(\n\t$fullPath: ID!\n) {\n\tproject(fullPath: $fullPath) {\n\t\tid\n\t}\n}",o=(await this.graphql(t,e,n,i,{fullPath:`${r}/${a}`},s))?.data?.project?.id;if(null==o)return;const l=/gid:\/\/gitlab\/Project\/([0-9]+)\b/.exec(o);if(null==l)return;const u=l[1];return null!=s&&(s.exitDetails=`â€¢ projectId=${u}`),u}catch(e){if(e instanceof l.Ww)return;return void this.handleException(e,t,s)}}async graphql(t,e,r,s,i,u){let c;try{const a=d.Yd.logLevel===o.in.Debug||d.Yd.isDebugging?new m.u(`[GITLAB] POST ${r}`,{log:!1}):void 0,u=this.getProxyAgent(t);try{if(c=await(0,n.a_)(t.getIgnoreSSLErrors(),(()=>(0,n.he)(`${r??"https://gitlab.com/api"}/graphql`,{method:"POST",headers:{Authorization:`Bearer ${e}`,"Content-Type":"application/json"},agent:u,body:JSON.stringify({query:s,variables:i})}))),c.ok){const t=await c.json();if("errors"in t)throw new l.Xq("GitLab",c,t.errors);return t}throw new l.Xq("GitLab",c)}finally{const t=` ${/(^[^({\n]+)/.exec(s)?.[1].trim()??s}`;a?.stop({message:t})}}catch(r){throw r instanceof l.Xq?this.handleRequestError(t,e,r,u):d.Yd.isDebugging&&a.window.showErrorMessage(`GitLab request failed: ${r.message}`),r}}async request(t,e,r,s,i,u){const c=`${r??"https://gitlab.com/api"}/${s}`;let h;try{const r=d.Yd.logLevel===o.in.Debug||d.Yd.isDebugging?new m.u(`[GITLAB] ${i?.method??"GET"} ${c}`,{log:!1}):void 0,a=this.getProxyAgent(t);try{if(h=await(0,n.a_)(t.getIgnoreSSLErrors(),(()=>(0,n.he)(c,{headers:{Authorization:`Bearer ${e}`,"Content-Type":"application/json"},agent:a,...i}))),h.ok){return await h.json()}throw new l.Xq("GitLab",h)}finally{r?.stop()}}catch(r){throw r instanceof l.Xq?this.handleRequestError(t,e,r,u):d.Yd.isDebugging&&a.window.showErrorMessage(`GitLab request failed: ${r.message}`),r}}handleRequestError(t,e,r,n){switch(r.status){case 404:case 410:case 422:throw new l.Ww(r);case 401:throw new l._7("gitlab",l.Jx.Unauthorized,r);case 403:if(r.message.includes("rate limit exceeded")){let t;const a=r.response?.headers?.get("x-ratelimit-reset");throw null!=a&&(t=parseInt(a,10),Number.isNaN(t)&&(t=void 0)),new l.yx(r,e,t)}throw new l._7("gitlab",l.Jx.Forbidden,r);case 500:return d.Yd.error(r,n),void(null!=r.response&&(t?.trackRequestException(),(0,g.vF)(`${t?.name??"GitLab"} failed to respond and might be experiencing issues.${t?.custom?"":" Please visit the [GitLab status page](https://status.gitlab.com) for more information."}`)));case 502:if(d.Yd.error(r,n),r.message.includes("timeout"))return t?.trackRequestException(),void(0,g.s$)(t?.name??"GitLab");break;default:if(r.status>=400&&r.status<500)throw new l.Bn(r)}d.Yd.error(r,n),d.Yd.isDebugging&&a.window.showErrorMessage(`GitLab request failed: ${r.response?.errors?.[0]?.message??r.message}`)}handleException(t,e,r){return d.Yd.error(t,r),t instanceof l._7&&this.showAuthenticationErrorMessage(t,e),t}async showAuthenticationErrorMessage(t,e){if(t.reason===l.Jx.Unauthorized||t.reason===l.Jx.Forbidden){const r="Reauthenticate";await a.window.showErrorMessage(`${t.message}. Would you like to try reauthenticating${t.reason===l.Jx.Forbidden?" to provide additional access":""}?`,r)===r&&await e.reauthenticate()}else a.window.showErrorMessage(t.message)}}y([(0,p.fF)({args:{0:t=>t.name,1:"<token>"}})],GitLabApi.prototype,"getAccountForCommit",1),y([(0,p.fF)({args:{0:t=>t.name,1:"<token>"}})],GitLabApi.prototype,"getAccountForEmail",1),y([(0,p.fF)({args:{0:t=>t.name,1:"<token>"}})],GitLabApi.prototype,"getDefaultBranch",1),y([(0,p.fF)({args:{0:t=>t.name,1:"<token>"}})],GitLabApi.prototype,"getIssueOrPullRequest",1),y([(0,p.fF)({args:{0:t=>t.name,1:"<token>"}})],GitLabApi.prototype,"getPullRequestForBranch",1),y([(0,p.fF)({args:{0:t=>t.name,1:"<token>"}})],GitLabApi.prototype,"getPullRequestForCommit",1)},6630:(t,e,r)=>{r.r(e),r.d(e,{GitLabMergeRequest:()=>a,GitLabMergeRequestREST:()=>s,GitLabMergeRequestState:()=>o});var a,n,s,i=r(4092),o=(t=>(t.OPEN="opened",t.CLOSED="closed",t.MERGED="merged",t.LOCKED="locked",t))(o||{});(n=a||(a={})).fromState=function(t){return"merged"===t?i.o0.Merged:"closed"===t||"locked"===t?i.o0.Closed:i.o0.Open},n.toState=function(t){return t===i.o0.Merged?"merged":t===i.o0.Closed?"closed":"opened"},(s||(s={})).from=function(t,e){return new i.i7(e,{name:t.author?.name??"Unknown",avatarUrl:t.author?.avatar_url??"",url:t.author?.web_url??""},String(t.iid),t.title,t.web_url,a.fromState(t.state),new Date(t.updated_at),null==t.closed_at?void 0:new Date(t.closed_at),null==t.merged_at?void 0:new Date(t.merged_at))}}};